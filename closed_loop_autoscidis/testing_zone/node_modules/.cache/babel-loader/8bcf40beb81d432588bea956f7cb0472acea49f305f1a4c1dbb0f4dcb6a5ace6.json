{"ast":null,"code":"import { doc, getDoc, updateDoc, setDoc } from 'firebase/firestore';\nconst getCondition = async function (db, study) {\n  let pId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  /**\n   * Get the metadata to check if there is an available condition\n   * if there is an available condition:\n   *  set start_time in the metadata\n   *  get condition from the db and return id and condition\n   * if there is no condition:\n   *  redirect to an error page\n   */\n  const docRefMeta = doc(db, study, 'autora_meta');\n  const docSnapMeta = await getDoc(docRefMeta);\n  const meta = docSnapMeta.data();\n  for (let key in meta) {\n    if (meta[key]['start_time'] === null) {\n      const unixTime = Math.floor(Date.now() / 1000);\n      await updateDoc(docRefMeta, {\n        [key]: {\n          'start_time': unixTime,\n          'finished': false,\n          'pId': pId\n        }\n      });\n      const docRefCondition = doc(db, study, 'autora_in', 'conditions', key);\n      const docSnapCondition = await getDoc(docRefCondition);\n      const condition = docSnapCondition.data()[key];\n      return [key, condition];\n    }\n  }\n  return false;\n};\nconst setObservation = async function (db, study, id, observation) {\n  let meta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  /**\n   * Set the metadata of the id to finished and save the data to the autora observation table\n   * if meta is set to false, set don't set metadata.\n   */\n  let retryCount = 0;\n  const MAX_RETRIES = 10;\n  const DELAY_MS = 1000;\n  while (retryCount < MAX_RETRIES) {\n    try {\n      if (meta) {\n        const docRefMeta = doc(db, study, 'autora_meta');\n        await updateDoc(docRefMeta, {\n          [\"\".concat(id, \".finished\")]: true\n        });\n      }\n      const docRefOut = doc(db, study, 'autora_out', 'observations', id);\n      await setDoc(docRefOut, {\n        [id]: observation\n      });\n      return;\n    } catch (error) {\n      retryCount++;\n      await new Promise(resolve => setTimeout(resolve, DELAY_MS));\n    }\n  }\n};\nconst setBackup = async (db, study, id, condition, observation) => {\n  /**\n   * Save the data to the backup table without updating metadata.\n   */\n  const time = Date.now();\n  const docRefOut = doc(db, study, 'autora_out', 'data_all', \"\".concat(id, \"_\").concat(time.toString()));\n  await setDoc(docRefOut, {\n    'condition': condition,\n    'observation': observation\n  });\n};\nexport { getCondition, setObservation, setBackup };","map":{"version":3,"names":["doc","getDoc","updateDoc","setDoc","getCondition","db","study","pId","arguments","length","undefined","docRefMeta","docSnapMeta","meta","data","key","unixTime","Math","floor","Date","now","docRefCondition","docSnapCondition","condition","setObservation","id","observation","retryCount","MAX_RETRIES","DELAY_MS","concat","docRefOut","error","Promise","resolve","setTimeout","setBackup","time","toString"],"sources":["/workspaces/closed-loop-AutoSciDis/closed_loop_autoscidis/testing_zone/node_modules/autora-firebase-functions/index.js"],"sourcesContent":["import {doc, getDoc, updateDoc, setDoc} from 'firebase/firestore'\n\nconst getCondition = async (db, study, pId = null) => {\n    /**\n     * Get the metadata to check if there is an available condition\n     * if there is an available condition:\n     *  set start_time in the metadata\n     *  get condition from the db and return id and condition\n     * if there is no condition:\n     *  redirect to an error page\n     */\n    const docRefMeta = doc(db, study, 'autora_meta');\n    const docSnapMeta = await getDoc(docRefMeta);\n    const meta = docSnapMeta.data()\n    for (let key in meta) {\n        if (meta[key]['start_time'] === null) {\n            const unixTime = Math.floor(Date.now() / 1000);\n            await updateDoc(docRefMeta, {[key]: {'start_time': unixTime, 'finished': false, 'pId': pId}});\n            const docRefCondition = doc(db, study, 'autora_in', 'conditions', key);\n            const docSnapCondition = await getDoc(docRefCondition)\n            const condition = docSnapCondition.data()[key]\n            return [key, condition]\n        }\n    }\n    return false\n};\n\n\nconst setObservation = async (db, study, id, observation, meta = true) => {\n    /**\n     * Set the metadata of the id to finished and save the data to the autora observation table\n     * if meta is set to false, set don't set metadata.\n     */\n    let retryCount = 0\n    const MAX_RETRIES = 10\n    const DELAY_MS = 1000\n    while (retryCount < MAX_RETRIES) {\n        try {\n            if (meta) {\n                const docRefMeta = doc(db, study, 'autora_meta');\n                await updateDoc(docRefMeta, {[`${id}.finished`]: true});\n            }\n            const docRefOut = doc(db, study, 'autora_out', 'observations', id);\n            await setDoc(docRefOut, {[id]: observation})\n            return\n        } catch (error) {\n            retryCount++;\n            await new Promise(resolve => setTimeout(resolve, DELAY_MS))\n        }\n    }\n}\n\n\nconst setBackup = async (db, study, id, condition, observation) => {\n    /**\n     * Save the data to the backup table without updating metadata.\n     */\n    const time = Date.now()\n    const docRefOut = doc(db, study, 'autora_out', 'data_all', `${id}_${time.toString()}`);\n    await setDoc(docRefOut, {'condition': condition, 'observation': observation})\n}\n\n\nexport {getCondition, setObservation, setBackup}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}